<!DOCTYPE html>
<html>

<head>
    <title>矩形树图布局对比（完整实现）</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        .container {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            padding: 20px;
            background: #f5f5f5;
        }

        .chart {
            border: 1px solid #ddd;
            padding: 15px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .chart-title {
            text-align: center;
            font: 16px/1.5 'Arial', sans-serif;
            color: #333;
            margin-bottom: 10px;
        }

        .node {
            transition: opacity 0.2s;
        }

        .node:hover {
            opacity: 0.8;
            cursor: pointer;
        }
    </style>
</head>

<body>
    <div class="container" id="main-container"></div>

    <script>
        // 1. 数据结构
        const dataset = {
            name: "root",
            children: [
                { name: "A", value: 40 }, { name: "B", value: 35 },
                { name: "C", value: 30 }, { name: "D", value: 25 },
                { name: "E", value: 20 }, { name: "F", value: 15 },
                { name: "G", value: 10 }, { name: "H", value: 8 },
                { name: "I", value: 6 }, { name: "J", value: 4 },
                { name: "K", value: 3 }, { name: "L", value: 2 }
            ]
        };

        // 2. 布局配置
        const layouts = [
            { name: "SliceDice", tile: d3.treemapSliceDice },
            { name: "Squarify", tile: d3.treemapSquarify },
            { name: "Binary", tile: d3.treemapBinary },
            { name: "Spiral", tile: spiralTile },
            { name: "GoldenRatio", tile: (n, x0, y0, x1, y1) => squarify(1.618, n, x0, y0, x1, y1) },
            { name: "CustomSquarify", tile: customSquarify }
        ];

        // 3. 可视化参数
        const width = 320, height = 240;
        const color = d3.scaleOrdinal(d3.schemeTableau10);

        // 4. 初始化容器
        const container = d3.select("#main-container");

        layouts.forEach(layout => {
            const chart = container.append("div")
                .classed("chart", true);

            chart.append("div")
                .classed("chart-title", true)
                .text(layout.name);

            const svg = chart.append("svg")
                .attr("width", width)
                .attr("height", height);

            renderTreemap(svg, layout.tile);
        });

        // 5. 核心渲染函数
        function renderTreemap(svg, tileMethod) {
            const root = d3.hierarchy(dataset)
                .sum(d => d.value)
                .sort((a, b) => b.value - a.value);

            const treemap = d3.treemap()
                .tile(tileMethod)
                .size([width, height])
                .padding(2)
                .round(true);

            console.log(root);

            treemap(root);

            const nodes = svg.selectAll("g")
                .data(root.leaves())
                .enter().append("g")
                .attr("class", "node")
                .attr("transform", d => `translate(${d.x0},${d.y0})`);

            nodes.append("rect")
                .attr("width", d => d.x1 - d.x0)
                .attr("height", d => d.y1 - d.y0)
                .attr("fill", d => color(d.data.name));

            nodes.append("text")
                .text(d => d.data.name)
                .attr("x", 4)
                .attr("y", 14)
                .style("font-size", "10px")
                .style("fill", "white");
        }

        // 6. 自定义布局算法实现
        // ========== 核心正交化算法 ==========
        function squarify(ratio, parent, x0, y0, x1, y1) {
            const nodes = parent.children;
            const n = nodes.length;
            let i0 = 0, i1 = 0;
            let total = parent.value;

            while (i0 < n) {
                let sumRow = 0, minVal = Infinity, maxVal = -Infinity;
                const dx = x1 - x0, dy = y1 - y0;
                const horizontal = dx >= dy;
                const alpha = (horizontal ? dy / dx : dx / dy) / (total * ratio);

                // 确定当前行包含的节点
                do {
                    const node = nodes[i1];
                    sumRow += node.value;
                    minVal = Math.min(minVal, node.value);
                    maxVal = Math.max(maxVal, node.value);
                    i1++;
                } while (i1 < n && canGrowRow(nodes, i0, i1, sumRow, alpha, minVal, maxVal));

                // 修复点：将 sumRow 传递给 layoutRow
                layoutRow(nodes.slice(i0, i1), x0, y0, x1, y1, horizontal, sumRow / total, sumRow);

                // 更新剩余空间
                if (horizontal) {
                    y0 += dy * (sumRow / total);
                } else {
                    x0 += dx * (sumRow / total);
                }
                total -= sumRow;
                i0 = i1;
            }

            return parent;

            function canGrowRow(nodes, i0, i1, sumCurrent, alpha, currentMin, currentMax) {
                if (i1 <= i0 + 1) return true;

                const beta = sumCurrent * sumCurrent * alpha;
                const ratio = Math.max(currentMax / beta, beta / currentMin);

                const newSum = sumCurrent + nodes[i1].value;
                const newBeta = newSum * newSum * alpha;
                const newRatio = Math.max(
                    Math.max(currentMax, nodes[i1].value) / newBeta,
                    newBeta / Math.min(currentMin, nodes[i1].value)
                );

                return newRatio <= ratio;
            }

            // 修复点：添加 sumRow 参数
            function layoutRow(rowNodes, x0, y0, x1, y1, horizontal, scale, sumRow) {
                if (horizontal) {
                    const h = (y1 - y0) * scale;
                    let x = x0;
                    rowNodes.forEach(node => {
                        const w = (x1 - x0) * (node.value / sumRow);
                        node.x0 = x;
                        node.x1 = x + w;
                        node.y0 = y0;
                        node.y1 = y0 + h;
                        x += w;
                    });
                } else {
                    const w = (x1 - x0) * scale;
                    let y = y0;
                    rowNodes.forEach(node => {
                        const h = (y1 - y0) * (node.value / sumRow);
                        node.x0 = x0;
                        node.x1 = x0 + w;
                        node.y0 = y;
                        node.y1 = y + h;
                        y += h;
                    });
                }
            }
        }

        // ========== 其他自定义布局 ==========
        // 自定义正交化（保持顺序）
        function customSquarify(node, x0, y0, x1, y1) {
            return squarify(1.6, node, x0, y0, x1, y1);
        }

        // 螺旋布局（简化实现）
        function spiralTile(node, x0, y0, x1, y1) {
            const children = node.children;
            const centerX = (x0 + x1) / 2;
            const centerY = (y0 + y1) / 2;
            let angle = 0, radius = 0;

            children.forEach(child => {
                const area = child.value;
                const r = Math.sqrt(area) * 0.8;
                const x = centerX + radius * Math.cos(angle);
                const y = centerY + radius * Math.sin(angle);

                child.x0 = x - r / 2;
                child.x1 = x + r / 2;
                child.y0 = y - r / 2;
                child.y1 = y + r / 2;

                radius += r * 0.3;
                angle += Math.PI / (4 + children.length * 0.1);
            });
            console.log(node);

            return node;
        }
    </script>
</body>

</html>